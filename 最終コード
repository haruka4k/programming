 import sympy as sp

# å¤‰æ•°å®šç¾©
n = sp.Symbol('n')

# å„ãƒ«ãƒ¼ãƒ«ã®é©ç”¨
def apply_rule(expr, rule):
    if rule == 1:
        return (2 * expr - 1) / 3
    elif rule == 2:
        return 4 * expr / 3
    elif rule == 3:
        return 4 * expr + 2
    else:
        raise ValueError("ä¸æ­£ãªãƒ«ãƒ¼ãƒ«")

# åˆæˆé–¢æ•° f(n)
def build_fn(rule_sequence):
    expr = n
    for rule in rule_sequence:
        expr = apply_rule(expr, rule)
    return sp.simplify(expr)

# å¢—åŠ ç‡ Î³(n)
def compute_growth_rate_fn(f_n):
    return sp.simplify((6 * f_n + 4) / (6 * n + 4))

# æ§‹æ–‡æ¡ä»¶ã®å°å‡ºï¼ˆ+è£œæ­£ï¼‰
def extract_congruence_from_fn(f_n, terminal_rule, first_rule):
    if terminal_rule == 1:
        expr = (f_n - 1) / 2
    elif terminal_rule == 2:
        expr = f_n / 4
    elif terminal_rule == 3:
        expr = (f_n - 2) / 4
    else:
        raise ValueError("æœªçŸ¥ã®çµ‚ç«¯ãƒ«ãƒ¼ãƒ«")

    numer, denom = expr.as_numer_denom()
    numer = sp.simplify(numer)
    denom = sp.simplify(denom)
    An = sp.expand(numer)
    A = An.coeff(n)
    B = sp.simplify(An - A * n)

    if denom == 1 or A == 0:
        r, m = 0, 1
    else:
        A_inv = sp.mod_inverse(A, denom)
        r = int((-B * A_inv) % denom)
        m = int(denom)

    if r == 0 and first_rule != 3:
        r = m

    return r, m

# å…¨ä½“è§£æ
def full_analysis(rule_sequence):
    f_n = build_fn(rule_sequence)
    Î³_n = compute_growth_rate_fn(f_n)
    terminal_rule = rule_sequence[-1]
    first_rule = rule_sequence[0]
    r, m = extract_congruence_from_fn(f_n, terminal_rule, first_rule)
    f_r = f_n.subs(n, r)

    return {
        "æ“ä½œç³»åˆ—": rule_sequence,
        "f(n)": f_n,
        "Î³(n)": Î³_n,
        "æ§‹æ–‡æ¡ä»¶": f"n â‰¡ {r} mod {m}",
        "æœ€å°ã®æ§‹æ–‡çš„ n": r,
        "å‡ºåŠ›å€¤ f(r)": f_r,
        "6n+4": 6 * r + 4,
        "6f(n)+4": 6 * f_r + 4,
        "å¢—åŠ é‡": sp.simplify(6 * f_r + 4 - (6 * r + 4)),
        "å¢—åŠ ç‡ï¼ˆæ•°å€¤ï¼‰": sp.simplify((6 * f_r + 4) / (6 * r + 4))
    }

# è§£æå®Ÿè¡Œç”¨ï¼ˆã‚«ãƒ³ãƒå…¥åŠ›å¯¾å¿œï¼‰
def analyze_from_input(input_str: str):
    try:
        rule_sequence = [int(x.strip()) for x in input_str.split(',')]
        return full_analysis(rule_sequence)
    except Exception as e:
        print("å…¥åŠ›ã‚¨ãƒ©ãƒ¼:", e)
        return None

# çµæœè¡¨ç¤º
def print_analysis_result(result):
    if result is None:
        return
    print("\nğŸ” è§£æçµæœ")
    print("------------")
    for key, value in result.items():
        print(f"{key}: {value}")

# å®Ÿè¡Œéƒ¨ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šå…¥åŠ›ï¼‰
if __name__ == "__main__":
    user_input = input("æ“ä½œç³»åˆ—ã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: 1,2,3ï¼‰: ")
    result = analyze_from_input(user_input)
    print_analysis_result(result)
