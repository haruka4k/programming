from sympy import symbols, simplify, Mod, Eq, solve, gcd

# 記号定義
n = symbols('n')

# 操作ルール定義
def apply_rule(expr, rule):
    if rule == 1:
        return (2 * expr - 1) / 3
    elif rule == 2:
        return (4 * expr) / 3
    elif rule == 3:
        return 4 * expr + 2
    else:
        raise ValueError("ルールは1〜3で指定してください")

# 終端ルールの構文条件（分子、分母の形で返す）
def get_terminal_condition(expr, rule):
    if rule == 1:
        cond_expr = simplify((expr - 1))   # (f(n) - 1)/2 → 分子
        modulus = 2
    elif rule == 2:
        cond_expr = simplify(expr)         # f(n)/4 → 分子
        modulus = 4
    elif rule == 3:
        cond_expr = simplify(expr - 6)     # (f(n) - 6)/12 → 分子
        modulus = 12
    else:
        raise ValueError("ルールは1〜3で指定してください")
    return cond_expr, modulus

# n に関する mod 条件を導出（f(n)の分子とmodから）
def derive_n_mod_condition(numerator, modulus):
    # numerator ≡ 0 mod modulus → 解を n について求める
    congruence = Eq(Mod(numerator, modulus), 0)
    solutions = solve(congruence, n)
    return solutions

# --- 実行部 ---
rules_input = input("操作系列をカンマ区切りで入力（例: 1,2,3）: ")
rule_sequence = [int(x.strip()) for x in rules_input.split(",")]

# 1. 増加量関数 f(n)
expr = n
for rule in rule_sequence:
    expr = apply_rule(expr, rule)
f_n = simplify(expr)

# 2. 増加率関数 γ(n)
gamma = simplify(f_n / n)

# 3. 終端操作の取得
terminal_rule = rule_sequence[-1]

# 4. 構文条件（分子, 分母）を取得
numerator, modulus = get_terminal_condition(f_n, terminal_rule)

# 5. n に関する条件を導出
print(f"\n操作系列: {rule_sequence}")
print(f"増加量関数 f(n): {f_n}")
print(f"増加率関数 γ(n): {gamma}")
print(f"終端操作: ルール{terminal_rule}")
print(f"構文条件: {numerator} ≡ 0 mod {modulus}")

# 6. n に関するmod条件を解く
print("\nn に関する構文的一致条件:")
n_solutions = solve(Eq(Mod(numerator, modulus), 0), n)

if n_solutions:
    print("n ≡", n_solutions[0], f"mod {modulus // gcd(numerator.as_numer_denom()[0].as_coefficients_dict().get(n, 1), modulus)}")
else:
    print("条件を満たす n の形式が導出できませんでした")
