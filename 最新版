import sympy as sp
n = sp.Symbol('n')
from sympy import simplify, factor, Mod

# æ“ä½œã‚’é©ç”¨
def apply_rule(expr, rule):
    if rule == 1:
        return (2 * expr - 1) / 3
    elif rule == 2:
        return 4 * expr / 3
    elif rule == 3:
        return 4 * expr + 2
    else:
        raise ValueError("ä¸æ­£ãªãƒ«ãƒ¼ãƒ«")

# å¢—åŠ é‡é–¢æ•°ã‚’ç”Ÿæˆ
def build_fn(rule_sequence):
    expr = n
    for rule in rule_sequence:
        expr = apply_rule(expr, rule)
    return simplify(expr)

# åˆ†æ¯ã‚’æŠ½å‡ºã™ã‚‹æ³¥è‡­ã„æ–¹æ³•
def robust_extract_numer_denom(f_n):
    numer, denom = f_n.as_numer_denom()
    if not denom.is_Integer:
        denom = sp.denom(simplify(f_n))
        numer = simplify(f_n * denom)
    return numer, denom

# æ§‹æ–‡æ¡ä»¶ã®å°å‡º
def extract_condition_and_factors(f_n, terminal_rule):
    if terminal_rule == 1:
        condition_expr = (f_n - 1) / 2
    elif terminal_rule == 2:
        condition_expr = f_n / 4
    elif terminal_rule == 3:
        condition_expr = (f_n - 6) / 12
    else:
        raise ValueError("ä¸æ­£ãªçµ‚ç«¯ãƒ«ãƒ¼ãƒ«")
    numerator = simplify(condition_expr.as_numer_denom()[0])
    denominator = simplify(condition_expr.as_numer_denom()[1])
    return {
        "æ¡ä»¶å¼": condition_expr,
        "åˆ†å­": numerator,
        "åˆ†æ¯": denominator,
        "åˆ†å­ã®å› æ•°åˆ†è§£": factor(numerator),
        "åˆ†æ¯ã®å› æ•°åˆ†è§£": factor(denominator)
    }

# åˆ¤åˆ¥å¼ã®å°å‡º
def derive_n_condition_strict(a, b):
    A = sp.LC(sp.expand(a), n)
    B = simplify(sp.expand(a) - A * n)
    m = b
    A_inv = sp.mod_inverse(A, m)
    r = Mod(-B * A_inv, m)
    return {
        "a â‰¡ 0 mod b": f"{A}*n + ({B}) â‰¡ 0 mod {m}",
        "A": A,
        "B": B,
        "A^-1 mod b": A_inv,
        "n â‰¡ r mod m": f"n â‰¡ {r} mod {m}"
    }

# å¢—åŠ ç‡é–¢æ•°
def compute_growth_rate(f_n):
    numerator = 6 * f_n + 4
    denominator = 6 * n + 4
    growth_rate = simplify(numerator / denominator)
    return {
        "å¢—åŠ ç‡é–¢æ•°": growth_rate,
        "åˆ†å­": simplify(numerator),
        "åˆ†æ¯": simplify(denominator)
    }

# ä¸€è²«å‡¦ç†é–¢æ•°
def full_analysis(rule_sequence):
    f_n = build_fn(rule_sequence)
    numer, denom = robust_extract_numer_denom(f_n)
    terminal = rule_sequence[-1]
    condition = derive_n_condition_strict(numer, denom)
    condition_factored = extract_condition_and_factors(f_n, terminal)
    growth_rate = compute_growth_rate(f_n)

    return {
        "æ“ä½œç³»åˆ—": rule_sequence,
        "f(n)": f_n,
        "æ¡ä»¶å¼": condition_factored,
        "åˆ¤åˆ¥å¼": condition,
        "å¢—åŠ ç‡é–¢æ•°": growth_rate
    }

# ğŸ”¶ å¤–éƒ¨å…¥åŠ›ã«å¯¾å¿œï¼š1,2,3 ã‚’å—ã‘å–ã£ã¦ [1, 2, 3] ã«å¤‰æ›
user_input = input("æ“ä½œç³»åˆ—ã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼š1,2,3ï¼‰: ")
rule_sequence = [int(x.strip()) for x in user_input.split(',')]

# å®Ÿè¡Œ
result = full_analysis(rule_sequence)
for key, value in result.items():
    print(f"\nğŸŸ¦ {key}:\n{value}")
