from sympy import symbols, simplify, Eq, Mod, numer, denom, solve

# 変数定義
n = symbols('n')

# 操作ルール関数（ルール1〜3）
def apply_rule(expr, rule):
    if rule == 1:
        return (2 * expr - 1) / 3
    elif rule == 2:
        return (4 * expr) / 3
    elif rule == 3:
        return 4 * expr + 2
    else:
        raise ValueError("無効なルール番号です")

# 終端ルールによる構文条件式の生成（xとおいてから変形）
def get_mod_condition_expr(f_n, terminal_rule):
    x = f_n  # f(n) を x と置く

    if terminal_rule == 1:
        expr = (x - 1) / 2
    elif terminal_rule == 2:
        expr = x / 4
    elif terminal_rule == 3:
        expr = (x - 6) / 12
    else:
        raise ValueError("無効な終端ルール")

    # 分子・分母取得
    num = numer(simplify(expr))
    mod_val = denom(simplify(expr))

    # モジュラー式生成
    return Eq(Mod(num, mod_val), 0), num, mod_val

# === メイン処理 ===
# 入力例: 1,1,1
rules_input = input("操作系列（例: 1,1,1）: ")
rule_sequence = [int(x.strip()) for x in rules_input.split(',')]

# f(n)の構築
expr = n
for r in rule_sequence:
    expr = apply_rule(expr, r)
f_n = simplify(expr)

# 終端ルール
terminal_rule = rule_sequence[-1]

# 構文条件の導出
congruence, num_expr, mod_base = get_mod_condition_expr(f_n, terminal_rule)

# 出力
print(f"\nf(n) = {f_n}")
print(f"終端ルール: ルール{terminal_rule}")
print(f"構文変形: 分子 = {num_expr}, 分母 = {mod_base}")
print(f"⇒ 構文条件: {num_expr} ≡ 0 mod {mod_base}")
print(f"合同式: {congruence}")

# nに関する解を導出（可能なら）
try:
    sol = solve(congruence, n)
    if sol:
        print("n に関する解:", sol)
    else:
        print("解なし、または式にnが含まれていません")
except Exception as e:
    print("エラー:", e)

