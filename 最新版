import sympy as sp
n = sp.Symbol('n')
from sympy import simplify, factor, Mod

# 操作を適用
def apply_rule(expr, rule):
    if rule == 1:
        return (2 * expr - 1) / 3
    elif rule == 2:
        return 4 * expr / 3
    elif rule == 3:
        return 4 * expr + 2
    else:
        raise ValueError("不正なルール")

# 増加量関数を生成
def build_fn(rule_sequence):
    expr = n
    for rule in rule_sequence:
        expr = apply_rule(expr, rule)
    return simplify(expr)

# 分母を抽出する泥臭い方法
def robust_extract_numer_denom(f_n):
    numer, denom = f_n.as_numer_denom()
    if not denom.is_Integer:
        denom = sp.denom(simplify(f_n))
        numer = simplify(f_n * denom)
    return numer, denom

# 構文条件の導出
def extract_condition_and_factors(f_n, terminal_rule):
    if terminal_rule == 1:
        condition_expr = (f_n - 1) / 2
    elif terminal_rule == 2:
        condition_expr = f_n / 4
    elif terminal_rule == 3:
        condition_expr = (f_n - 6) / 12
    else:
        raise ValueError("不正な終端ルール")
    numerator = simplify(condition_expr.as_numer_denom()[0])
    denominator = simplify(condition_expr.as_numer_denom()[1])
    return {
        "条件式": condition_expr,
        "分子": numerator,
        "分母": denominator,
        "分子の因数分解": factor(numerator),
        "分母の因数分解": factor(denominator)
    }

# 判別式の導出
def derive_n_condition_strict(a, b):
    A = sp.LC(sp.expand(a), n)
    B = simplify(sp.expand(a) - A * n)
    m = b
    A_inv = sp.mod_inverse(A, m)
    r = Mod(-B * A_inv, m)
    return {
        "a ≡ 0 mod b": f"{A}*n + ({B}) ≡ 0 mod {m}",
        "A": A,
        "B": B,
        "A^-1 mod b": A_inv,
        "n ≡ r mod m": f"n ≡ {r} mod {m}"
    }

# 増加率関数
def compute_growth_rate(f_n):
    numerator = 6 * f_n + 4
    denominator = 6 * n + 4
    growth_rate = simplify(numerator / denominator)
    return {
        "増加率関数": growth_rate,
        "分子": simplify(numerator),
        "分母": simplify(denominator)
    }

# 一貫処理関数
def full_analysis(rule_sequence):
    f_n = build_fn(rule_sequence)
    numer, denom = robust_extract_numer_denom(f_n)
    terminal = rule_sequence[-1]
    condition = derive_n_condition_strict(numer, denom)
    condition_factored = extract_condition_and_factors(f_n, terminal)
    growth_rate = compute_growth_rate(f_n)

    return {
        "操作系列": rule_sequence,
        "f(n)": f_n,
        "条件式": condition_factored,
        "判別式": condition,
        "増加率関数": growth_rate
    }

# 🔶 外部入力に対応：1,2,3 を受け取って [1, 2, 3] に変換
user_input = input("操作系列をカンマで区切って入力してください（例：1,2,3）: ")
rule_sequence = [int(x.strip()) for x in user_input.split(',')]

# 実行
result = full_analysis(rule_sequence)
for key, value in result.items():
    print(f"\n🟦 {key}:\n{value}")
